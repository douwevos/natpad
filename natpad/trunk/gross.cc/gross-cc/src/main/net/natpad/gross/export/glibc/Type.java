package net.natpad.gross.export.glibc;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;

public class Type {

	public final String filename;
	public final ClassName className;
	
	private final HashMap<ClassName, ClassName> importList = new HashMap<ClassName, ClassName>();
	
	public final HashMap<String, Field> fieldList = new HashMap<String, Field>();
	
	private final List<Method> methodList = new ArrayList<Method>();
	
	private final List<InterfaceImplement> implementsList = new ArrayList<InterfaceImplement>();
	
	boolean clean;
	boolean hasPrivateFields;
	
	public Type(ClassName className, String filename) {
		this.className = className;
		this.filename = filename;
	}
	
	
	public void addImport(ClassName importName) {
		if (className.equals(importName)) {
			return;
		}
		importList.put(importName, importName);
	}
	
	
	public void addField(String fieldname, ClassName fieldtype, boolean isPrivate) {
		fieldList.put(fieldname, new Field(fieldtype, fieldname, isPrivate));
	}

	
	public void addInterface(InterfaceImplement iface) {
		implementsList.add(iface);
	}
	
	public void addMethod(Method method) {
		methodList.add(method);
	}

	
	public void createHeaderFile(File basedir) throws IOException {
		ensureClean();
		File file = new File(basedir, filename+".h");
		PrintWriter outH = new PrintWriter(new FileOutputStream(file, false));

		ClassName cn = className;
		String cmlName = cn.camelPrefix+cn.camelPostfix;
		
		String dateAsStr = new SimpleDateFormat("yyyy.MM.dd G 'at' HH:mm:ss z").format(new Date());
		outH.println("/* This file was generated by Gross-CC on "+dateAsStr+" */");
		outH.println("#ifndef "+cn.upPrefix+""+cn.upPostfix+"_H_");
		outH.println("#define "+cn.upPrefix+""+cn.upPostfix+"_H_");
		outH.println();

		HashSet<String> importAdded = new HashSet<String>();
		for(ClassName importClsName : importList.keySet()) {
			String fhn = fullHeaderName(importClsName);
			if (importAdded.add(fhn)) {
				outH.println("#include "+fhn);
			}
		}
		
		outH.println();
		outH.println("G_BEGIN_DECLS");
		outH.println();
		outH.println("#define "+cn.upPrefix+"_TYPE_"+cn.upPostfix+"              ("+cn.lowPrefix+"_"+cn.lowPostfix+"_get_type())");
		outH.println("#define "+cn.upPrefix+"_"+cn.upPostfix+"(obj)              (G_TYPE_CHECK_INSTANCE_CAST ((obj), "+cn.lowPrefix+"_"+cn.lowPostfix+"_get_type(), "+cmlName+"))");
		outH.println("#define "+cn.upPrefix+"_"+cn.upPostfix+"_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST ((klass), "+cn.upPrefix+"_TYPE_"+cn.upPostfix+", "+cmlName+"Class))");
		outH.println("#define "+cn.upPrefix+"_IS_"+cn.upPostfix+"(obj)           (G_TYPE_CHECK_INSTANCE_TYPE ((obj), "+cn.upPrefix+"_TYPE_"+cn.upPostfix+"))");
		outH.println("#define "+cn.upPrefix+"_IS_"+cn.upPostfix+"_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE ((klass), "+cn.upPrefix+"_TYPE_"+cn.upPostfix+"))");
		outH.println("#define "+cn.upPrefix+"_"+cn.upPostfix+"_GET_CLASS(obj)    (G_TYPE_INSTANCE_GET_CLASS ((obj), "+cn.upPrefix+"_TYPE_"+cn.upPostfix+", "+cmlName+"Class))");
		outH.println();
		outH.println();
		outH.println("typedef struct _"+cmlName+"               "+cmlName+";");
		if (hasPrivateFields) {
			outH.println("typedef struct _"+cmlName+"Private        "+cmlName+"Private;");
		}
		outH.println("typedef struct _"+cmlName+"Class          "+cmlName+"Class;");
		outH.println();
		outH.println();
		outH.println("struct _"+cmlName+" {");
		outH.println("	GObject parent;");

		for(String fieldname : fieldList.keySet()) {
			Field field = fieldList.get(fieldname);
			if (!field.isPrivate) {
				ClassName fieldtype = field.type;
				outH.println("	"+fieldtype.camelPrefix+fieldtype.camelPostfix+" *"+fieldname+";");
			}
		}
		
		outH.println("};");
		outH.println();
		outH.println("struct _"+cmlName+"Class {");
		outH.println("	GObjectClass parent_class;");
		outH.println("};");
		outH.println();
		outH.println();
		outH.println("GType "+cn.lowPrefix+"_"+cn.lowPostfix+"_get_type();");
		outH.println();
		
		for(Method method : methodList) {
			method.writeH(this, outH);
		}
		
		outH.println();
		outH.println("G_END_DECLS");
		outH.println();
		outH.println("#endif /* "+cn.upPrefix+""+cn.upPostfix+"_H_ */");

		outH.flush();
		outH.close();
	}


	private String fullHeaderName(ClassName importClsName) {
		String fname = importClsName.createFilename();
		if (fname!=null && fname.length()>0) {
			if (fname.endsWith(".h>") || fname.endsWith(".h\"")) {
			} else if (fname.endsWith(".h")) {
				fname = '"' + fname + '"';
			} else {
				fname = '"' + fname + ".h\"";
			}
		}
		return fname;
	}


	public void createCFile(File basedir) throws IOException {
		ensureClean();
		File file = new File(basedir, filename+".c");
		PrintWriter outC = new PrintWriter(new FileOutputStream(file, false));

		ClassName cn = className;
		String cmlName = cn.camelPrefix+cn.camelPostfix;
		
		String dateAsStr = new SimpleDateFormat("yyyy.MM.dd G 'at' HH:mm:ss z").format(new Date());
		outC.println("/* This file was generated by Gross-CC on "+dateAsStr+" */");
		outC.println("#include \""+filename+".h\"");
		HashSet<String> extr = new HashSet<>();
		for(InterfaceImplement ifaceImpl : implementsList) {
			String fullHeaderName = fullHeaderName(ifaceImpl.className);
			if (extr.add(fullHeaderName)) {
				outC.println("#include "+fullHeaderName);
			}
		}
		
		outC.println();
		if (hasPrivateFields) {
			outC.println("struct _"+cmlName+"Private {");
			for(String fieldname : fieldList.keySet()) {
				Field field = fieldList.get(fieldname);
				if (field.isPrivate) {
					ClassName fieldtype = field.type;
					outC.println("	"+fieldtype.fullTypePtr()+fieldname+";");
				}
			}
			
			outC.println("};");
			outC.println();
		}

		for(InterfaceImplement ifaceImpl : implementsList) {
			outC.println("static void l_"+ifaceImpl.className.lowPostfix+"_iface_init("+ifaceImpl.className.camelPrefix+ifaceImpl.className.camelPostfix+"Interface *iface);");
		}
		outC.println();

		outC.println("G_DEFINE_TYPE_WITH_CODE("+cmlName+", "+cn.lowPrefix+"_"+cn.lowPostfix+", G_TYPE_OBJECT,");
		if (hasPrivateFields) {
			outC.println("		G_ADD_PRIVATE("+cmlName+")");
		}
		for(InterfaceImplement ifaceImpl : implementsList) {
			ClassName icn = ifaceImpl.className;
			outC.println("		G_IMPLEMENT_INTERFACE("+icn.upPrefix+"_TYPE_"+icn.upPostfix+", l_"+icn.lowPostfix+"_iface_init)");
		}
		outC.println(");");
		outC.println();
		outC.println("#define L_SAFE_UNREF_PTR(p) { void *ptr = p; p = NULL; if (ptr) { g_object_unref(ptr); } }");
		outC.println("static G_GNUC_UNUSED void *L_SAFE_REF_PTR(void *p) { if (p) { g_object_ref(p); } return p; }");
		outC.println();
		
		
		outC.println("static void l_dispose(GObject *object);");
		outC.println();
		outC.println("static void "+cn.lowPrefix+"_"+cn.lowPostfix+"_class_init("+cmlName+"Class *clazz) {");
		outC.println("	GObjectClass *object_class = G_OBJECT_CLASS(clazz);");
		outC.println("	object_class->dispose = l_dispose;");
		outC.println("}");
		outC.println();
		outC.println("static void "+cn.lowPrefix+"_"+cn.lowPostfix+"_init("+cmlName+" *instance) {");
		outC.println("}");
		outC.println();
		outC.println("static void l_dispose(GObject *object) {");
		if (!fieldList.keySet().isEmpty()) {
			outC.println("	"+cmlName+" *instance = "+cn.upPrefix+"_"+cn.upPostfix+"(object);");
		}
		if (hasPrivateFields) {
			outC.println("	"+cmlName+"Private *priv = "+cn.lowPrefix+"_"+cn.lowPostfix+"_get_instance_private(instance);");
		}
		
		for(String fieldname : fieldList.keySet()) {
			Field field = fieldList.get(fieldname);
			if (field.type.isPointerType) {
				outC.println("	L_SAFE_UNREF_PTR("+(field.isPrivate ? "priv->" : "instance->")+field.name+");");
			}
		}
		
		
		outC.println("	G_OBJECT_CLASS("+cn.lowPrefix+"_"+cn.lowPostfix+"_parent_class)->dispose(object);");
		outC.println("}");
		
		outC.println();
		
		for(Method method : methodList) {
			method.writeC(this, outC);
		}
		
		
		
		for(InterfaceImplement ifaceImpl : implementsList) {
			ClassName icn = ifaceImpl.className;
			outC.println();
			outC.println("/******************** start "+icn.camelPrefix+icn.camelPostfix+" implementation  ********************/");
			outC.println();
			if (ifaceImpl.prefixContent!=null) {
				outC.println(ifaceImpl.prefixContent);
				outC.println();
			}
			for(String ifaceMName : ifaceImpl.methodMappings.keySet()) {
				Method method = ifaceImpl.methodMappings.get(ifaceMName);
				String tempMethodName = "l_"+ifaceImpl.className.lowPostfix+"_"+method.methodName;
				String mname = method.methodName;
				method.methodName = tempMethodName;
				Type ifacetype = new Type(ifaceImpl.className, null);
				method.writeC(ifacetype, outC);
				method.methodName = mname;
			}

			outC.println();
			outC.println("static void l_"+ifaceImpl.className.lowPostfix+"_iface_init("+ifaceImpl.className.camelPrefix+ifaceImpl.className.camelPostfix+"Interface *iface) {");
			for(String ifaceMName : ifaceImpl.methodMappings.keySet()) {
				Method method = ifaceImpl.methodMappings.get(ifaceMName);
				outC.println("	iface->"+ifaceMName+" = l_"+ifaceImpl.className.lowPostfix+"_"+method.methodName+";");
			}
			if (ifaceImpl.initText!=null) {
				outC.println(ifaceImpl.initText);
			}
			outC.println("}");
			outC.println();
			outC.println("/******************** end "+icn.camelPrefix+icn.camelPostfix+" implementation ********************/");
			outC.println();

		}

		
		outC.flush();
		outC.close();

	}


	private void ensureClean() {
		if (clean) {
			return;
		}
		
		clean = true;
		hasPrivateFields = false;
		
		for(Field field : fieldList.values()) {
			if (field.isPrivate) {
				hasPrivateFields = true;
				break;
			}
		}
		
	}


	public static class Field {
		public final ClassName type;
		public final String name;
		public final boolean isPrivate;
		public Field(ClassName type, String name, boolean isPrivate) {
			this.type = type;
			this.name = name;
			this.isPrivate = isPrivate;
		}
		
	}
	
	
	@Override
	public String toString() {
		return "Type["+className+"]";
	}
}
