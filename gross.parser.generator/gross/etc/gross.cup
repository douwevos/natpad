action code {:

#include <caterpillar.h>
#include "grosymbol.h"
#include "../bnf/grobnfactioncode.h"
#include "../bnf/grobnfproduction.h"
#include "../bnf/grobnfrhs.h"
#include "../bnf/grobnfrhsactioncode.h"
#include "../bnf/grobnfrhsentryunary.h"
#include "../bnf/grobnfspec.h"
#include "../bnf/grobnfsymbolpart.h"
#include "../bnf/grobnfsymboldeflist.h"
#include "../bnf/grobnfstacktype.h"
#include "../bnf/grobnfstring.h"
#include "../bnf/../grolocation.h"


static GroLocation *l_left_as_location(GroContent *content) {
	long long row;
	int column;
	gro_content_get_left(content, &row, &column);
	return gro_location_new(row, column);
}

static GroLocation *l_right_as_location(GroContent *content) {
	long long row;
	int column;
	gro_content_get_right(content, &row, &column);
	return gro_location_new(row, column);
}

:}


terminal
  PACKAGE, IMPORT, CODE, ACTION, PARSER, TERMINAL, NON, INIT, SCAN, WITH, 
  START, SEMI, COMMA, STAR, DOT, COLON, COLON_COLON_EQUALS, BAR, PRECEDENCE,
  LEFT, RIGHT, NONASSOC, PERCENT_PREC, LBRACK, RBRACK, NONTERMINAL, PLUS, EXCL, LPAREN, RPAREN;

terminal CatStringWo  ID, CODE_STRING;

non terminal
  package_spec, import_list, 
  code_part, opt_semi, non_terminal,
  parser_code_part,  
  import_spec, import_id, init_code, scan_code, 
   
  empty,
  precedence_list, preced, terminal_list, precedence_l;
  
non terminal GroBnfActionCode       action_code_part;
non terminal GroBnfSpec				spec;
non terminal GroBnfRhs				rhs, rhs_production;
non terminal GroBnfStackType		type_id;
non terminal GroBnfSymbolDefList	symbol;
non terminal GroBnfProductionPart	prod_part;
non terminal CatArrayWo				production, production_list;
non terminal CatArrayWo				symbol_list;
non terminal CatArrayWo				code_parts;
non terminal CatArrayWo				declares_term, declares_non_term;
non terminal CatArrayWo				term_name_list, non_term_name_list;

non terminal GroBnfString  			new_non_term_id, nt_id, symbol_id, label_id, opt_label, terminal_id,
                     				term_id, robust_id, new_term_id, multipart_id, start_spec;


non terminal GroBnfRhs				rhs_prod;
non terminal GObject				rhs_part, rhs_entry_complete;
non terminal GroBnfRhsActionCode	rhs_action_code;
non terminal GObject				rhs_entry;
non terminal CatArrayWo				rhs_prod_list, rhs_part_list, rhs_sub_list, rhs_sub;


/*----------------------------------------------------------------*/ 

start with spec;


spec ::=				  package_spec import_list code_parts:cp symbol_list:sl precedence_list start_spec:ss production_list:pl
							{:
								RESULT = gro_bnf_spec_new(cp, sl, pl, ss);
							:}
						|
						/* error recovery assuming something went wrong before symbols 
						   and we have TERMINAL or NON TERMINAL to sync on.  if we get
						   an error after that, we recover inside symbol_list or 
						   production_list 
						*/
						  error symbol_list:sl precedence_list start_spec:ss production_list:pl
							{:
								RESULT = gro_bnf_spec_new(NULL, sl, pl, ss);
							:}
						;


package_spec ::=		  PACKAGE multipart_id SEMI
						| empty
						;


import_list ::=			  import_list import_spec
						| empty
						;


import_spec ::=			  IMPORT import_id SEMI
						;


// allow any order; all parts are optional. [CSA, 23-Jul-1999]
// (we check in the part action to make sure we don't have 2 of any part)
code_part ::=			  action_code_part:ap 
							{:
								RESULT = ap;
							:}
						| parser_code_part
						| init_code
						| scan_code
						;

code_parts ::= 
						| code_parts:cps code_part:cp
							{:
								if (cps==NULL) {
									RESULT = cat_array_wo_new();
								} else {
									RESULT = cat_ref_ptr(cps);
								}
								cat_array_wo_append(RESULT, (GObject *) cp);
							:}
						;


action_code_part ::=	  ACTION CODE CODE_STRING:user_code opt_semi
							{: 
								GroLocation *start_loc = l_left_as_location(gro_user_code);
								GroLocation *end_loc = l_right_as_location(gro_user_code);
								GroBnfString *code_string = gro_bnf_string_new(user_code, start_loc, end_loc);
								RESULT = gro_bnf_action_code_new(code_string);
								cat_unref_ptr(code_string);
								cat_unref_ptr(start_loc);
								cat_unref_ptr(end_loc);
							:} 

						;


parser_code_part ::=	  PARSER CODE CODE_STRING:user_code opt_semi
						;


init_code ::=			  INIT WITH CODE_STRING:user_code opt_semi
						;


scan_code ::=			  SCAN WITH CODE_STRING:user_code opt_semi
						;


symbol_list ::=			  symbol_list:sl symbol:s
							{:
								RESULT = sl;
								cat_array_wo_append(sl, (GObject *) s);
							:}
						| symbol:s
							{:
								RESULT = cat_array_wo_new();
								cat_array_wo_append(RESULT, (GObject *) s);
							:}
						;


symbol ::=				  TERMINAL     type_id:ti declares_term:tl
							{:
								RESULT = gro_bnf_symbol_def_list_new(tl, ti, TRUE);
							:}
							
						| TERMINAL             declares_term:tl
							{:
								RESULT = gro_bnf_symbol_def_list_new(tl, NULL, TRUE);
							:}
						| non_terminal type_id:ti declares_non_term:tl
							{:
								RESULT = gro_bnf_symbol_def_list_new(tl, ti, FALSE);
							:}
						| non_terminal         declares_non_term:tl
							{:
								RESULT = gro_bnf_symbol_def_list_new(tl, NULL, FALSE);
							:}
						|
						/* error recovery productions -- sync on semicolon */
						  TERMINAL error SEMI
						| non_terminal error SEMI
						;


declares_term ::=		  term_name_list:tnl SEMI
							{:
								RESULT = tnl;
							:}
						;

declares_non_term ::=	  non_term_name_list:tnl SEMI
							{:
								RESULT = tnl;
							:}
						;

term_name_list ::=		  term_name_list:tnl COMMA new_term_id:nti
							{: 
								CatArrayWo *term_list = (CatArrayWo *) tnl; 
								cat_array_wo_append(term_list, (GObject *) nti); 
								RESULT=term_list;
							:}
						| new_term_id:nti
							{:
								CatArrayWo *term_list = cat_array_wo_new();
								cat_array_wo_append(term_list, (GObject *) nti);
								RESULT=term_list;
							:}
						;


non_term_name_list ::=	  non_term_name_list:tnl COMMA new_non_term_id:nti
							{: 
								CatArrayWo *term_list = (CatArrayWo *) tnl; 
								cat_array_wo_append(term_list, (GObject *) nti); 
								RESULT=term_list;
							:}
						| new_non_term_id:nti
							{:
								CatArrayWo *term_list = cat_array_wo_new();
								cat_array_wo_append(term_list, (GObject *) nti);
								RESULT=term_list;
							:}
						;



precedence_list ::=		  precedence_l
						| empty
						; 


precedence_l ::=		  precedence_l preced
						| preced
						;


preced ::=				  PRECEDENCE LEFT terminal_list SEMI
						| PRECEDENCE RIGHT terminal_list SEMI
						| PRECEDENCE NONASSOC terminal_list SEMI
						;


terminal_list ::=		  terminal_list COMMA terminal_id
						| terminal_id
						;


terminal_id ::=			  term_id:sym
						;

term_id ::=				  symbol_id:sym
						;


start_spec ::=			  START WITH nt_id:start_name SEMI
							{:
								RESULT = start_name;
							:}
						| empty
						;


production_list ::=		  production_list:pl production:p
							{:
								RESULT = pl;
								cat_array_wo_append_all(pl, p);
							:}
						| production:p
							{:
								RESULT = p;
							:}
						;

production ::=			  nt_id:lhs_id  COLON_COLON_EQUALS rhs_prod_list:rhsl SEMI
							{:
								RESULT = cat_array_wo_new();
								CatIIterator *iter = cat_array_wo_iterator(rhsl);
								while(cat_iiterator_has_next(iter)) {
									GroBnfRhs *rhs = (GroBnfRhs *) cat_iiterator_next(iter);
									GroBnfProduction *prod = gro_bnf_production_new(lhs_id, rhs);
									cat_array_wo_append(RESULT, (GObject *) prod);
									cat_unref_ptr(prod);
								}
								cat_unref_ptr(iter);
								
							:}
						| error SEMI:s
							{:
								RESULT = cat_array_wo_new();
							:}
						;


rhs_prod_list ::=		  rhs_prod_list:rl BAR rhs_prod:r
							{:
								RESULT = rl;
								cat_array_wo_append(RESULT, (GObject *) r);
							:}
						| rhs_prod:r
							{:
								RESULT = cat_array_wo_new();
								cat_array_wo_append(RESULT, (GObject *) r);
							:}
						;


rhs_prod ::=
						  rhs_part_list:r
							{:
								RESULT = gro_bnf_rhs_new(r);
							:}
						| rhs_part_list:r PERCENT_PREC ID:term_name
							{:
								RESULT = gro_bnf_rhs_new(r);
								GroLocation *start_loc = l_left_as_location(gro_term_name);
								GroLocation *end_loc = l_right_as_location(gro_term_name);
								GroBnfString *as_bnf_str = gro_bnf_string_new(term_name, start_loc, end_loc);
								cat_unref_ptr(start_loc);
								cat_unref_ptr(end_loc);
								
								gro_bnf_rhs_set_prec_term_name(RESULT, as_bnf_str);
							:}
						;



rhs_part_list ::=		  rhs_part_list:rhs rhs_part:pp
							{:
								cat_array_wo_append(rhs, (GObject *) pp);
								RESULT = rhs;
							:} 
						|
							{:
								RESULT = cat_array_wo_new();
							:} 
						;


rhs_part ::=			  rhs_entry_complete:rec
							{:
								RESULT = rec;
							:} 
						| rhs_action_code:rec
							{:
								RESULT = (GObject *) rec;
							:} 
						;


rhs_sub_list ::=		  rhs_sub_list:rsl BAR rhs_sub:sub
							{:
								RESULT = rsl;
								GroBnfRhs *bnf_sub = gro_bnf_rhs_new(sub);
								cat_array_wo_append(RESULT, (GObject *) bnf_sub);
								cat_unref_ptr(bnf_sub);
							:} 
						| rhs_sub:sub
							{:
								RESULT = cat_array_wo_new();
								GroBnfRhs *bnf_sub = gro_bnf_rhs_new(sub);
								cat_array_wo_append(RESULT, (GObject *) bnf_sub);
								cat_unref_ptr(bnf_sub);
							:} 
						;


rhs_sub ::=				  rhs_sub:s rhs_entry_complete:e
							{:
								cat_array_wo_append(s, (GObject *) e);
								RESULT = s;
							:} 
						| rhs_entry_complete:e
							{:
								RESULT = cat_array_wo_new();
								cat_array_wo_append(RESULT, (GObject *) e);
							:} 
						;


rhs_action_code ::=		  CODE_STRING:code_str
							{:
								GroLocation *start_loc = l_left_as_location(gro_code_str);
								GroLocation *end_loc = l_right_as_location(gro_code_str);
								GroBnfString *as_bnf_str = gro_bnf_string_new(code_str, start_loc, end_loc);
								cat_unref_ptr(start_loc);
								cat_unref_ptr(end_loc);
							
								RESULT = gro_bnf_rhs_action_code_new(as_bnf_str);
								cat_unref_ptr(as_bnf_str);
							:}
						;




rhs_entry_complete ::=
						  rhs_entry:j
							{:
								RESULT = j;
							:}
						| rhs_entry:j STAR
							{:
								RESULT = (GObject *) gro_bnf_rhs_entry_unary_new(j, GRO_ENTRY_UNARY_STAR);
							:}
						| rhs_entry:j PLUS
							{:
								RESULT = (GObject *) gro_bnf_rhs_entry_unary_new(j, GRO_ENTRY_UNARY_PLUS);
							:}
						| rhs_entry:j EXCL
							{:
								RESULT = (GObject *) gro_bnf_rhs_entry_unary_new(j, GRO_ENTRY_UNARY_EXCL);
							:}
						;


rhs_entry ::=			  LPAREN rhs_sub_list:j RPAREN
							{:
								RESULT = (GObject *) j;
							:}
						| symbol_id:symid opt_label:labid
							{:
								RESULT = (GObject *) gro_bnf_symbol_part_new(symid, labid);
							:}
						;

opt_label ::=			  COLON label_id:labid
							{:
								RESULT = labid;
							:}
						| empty 
						;

multipart_id ::=		  multipart_id:ba DOT robust_id:ad
							{:
								CatStringWo *e_multi = cat_string_wo_clone(gro_bnf_string_get_text(ba), CAT_CLONE_DEPTH_FULL);
								cat_string_wo_append_char(e_multi, '.');
								cat_string_wo_append(e_multi, gro_bnf_string_get_text(ad));
								GroLocation *start_loc = l_left_as_location(gro_ba);
								GroLocation *end_loc = l_right_as_location(gro_ad);
								RESULT = gro_bnf_string_new(e_multi, start_loc, end_loc);
							:} 
						| robust_id:an_id {: RESULT = an_id; :}
						;

import_id ::= 			  multipart_id DOT STAR 
						| multipart_id
						;


type_id ::=				  multipart_id:mi
							{:
								RESULT = gro_bnf_stack_type_new(mi);
							:}
						| type_id:ti LBRACK RBRACK:rbr
							{:
								CatStringWo *ti_name = gro_bnf_stack_type_get_as_text(ti);
								CatStringWo *nn = cat_string_wo_clone(ti_name, CAT_CLONE_DEPTH_FULL);
								cat_string_wo_append_chars_len(nn, "[]", 2);
								nn = cat_string_wo_anchor(nn, 0);
								GroLocation *start_loc = l_left_as_location(gro_ti);
								GroLocation *end_loc = l_right_as_location(gro_rbr);
								GroBnfString *new_st = gro_bnf_string_new(nn, start_loc, end_loc);
								RESULT = gro_bnf_stack_type_new(new_st);
								cat_unref_ptr(new_st);
								cat_unref_ptr(nn);
							:}
						;


new_term_id ::= 
						ID:term_id
							{:
								GroLocation *start_loc = l_left_as_location(gro_term_id);
								GroLocation *end_loc = l_right_as_location(gro_term_id);
								RESULT = gro_bnf_string_new(term_id, start_loc, end_loc);
								cat_unref_ptr(start_loc);
								cat_unref_ptr(end_loc);
							:} 
					;


new_non_term_id ::=
						ID:non_term_id
							{:
								GroLocation *start_loc = l_left_as_location(gro_non_term_id);
								GroLocation *end_loc = l_right_as_location(gro_non_term_id);
								RESULT = gro_bnf_string_new(non_term_id, start_loc, end_loc);
								cat_unref_ptr(start_loc);
								cat_unref_ptr(end_loc);
							:} 
					;

nt_id ::=
						ID:the_id 
							{: 
								GroLocation *start_loc = l_left_as_location(gro_the_id);
								GroLocation *end_loc = l_right_as_location(gro_the_id);
								RESULT = gro_bnf_string_new(the_id, start_loc, end_loc);
								cat_unref_ptr(start_loc);
								cat_unref_ptr(end_loc);
							:} 
					|	error
					;

symbol_id ::=
						ID:the_id
							{: 
								GroLocation *start_loc = l_left_as_location(gro_the_id);
								GroLocation *end_loc = l_right_as_location(gro_the_id);
								RESULT = gro_bnf_string_new(the_id, start_loc, end_loc);
								cat_unref_ptr(start_loc);
								cat_unref_ptr(end_loc);
							:} 
					|	error
					;


label_id ::= 
						robust_id:the_id
							{: 
								RESULT = the_id;
							:} 
					;
					

robust_id ::= /* all ids that aren't reserved words in Java */
						ID:the_id
							{: 
								GroLocation *start_loc = l_left_as_location(gro_the_id);
								GroLocation *end_loc = l_right_as_location(gro_the_id);
								RESULT = gro_bnf_string_new(the_id, start_loc, end_loc);
								cat_unref_ptr(start_loc);
								cat_unref_ptr(end_loc);
							:} 
						/* package is reserved. */
						/* import is reserved. */
					|	CODE
					|	ACTION
					|	PARSER
					|	TERMINAL
					|	NON
					|	NONTERMINAL
					|	INIT
					|	SCAN
					|	WITH
					|	START
					|	PRECEDENCE
					|	LEFT
					|	RIGHT
					|	NONASSOC
					|	error
					;

non_terminal ::= 
						NON TERMINAL
					|	NONTERMINAL
					;

opt_semi ::=
						/* nothing */
					|	SEMI
					;

empty ::=
						/* nothing */
					;
